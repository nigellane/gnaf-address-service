name: CD - Deploy to Production

on:
  push:
    branches: [ main ]
    tags: [ 'v*.*.*' ]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'staging'
        type: choice
        options:
        - staging
        - production
      force_deploy:
        description: 'Force deployment even if tests fail'
        required: false
        default: false
        type: boolean

env:
  NODE_VERSION: '20'
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  prepare:
    name: Prepare Deployment
    runs-on: ubuntu-latest
    
    outputs:
      environment: ${{ steps.env.outputs.environment }}
      image-tag: ${{ steps.env.outputs.image-tag }}
      deploy-ready: ${{ steps.env.outputs.deploy-ready }}

    steps:
    - name: Determine deployment environment
      id: env
      run: |
        if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
          ENVIRONMENT="${{ github.event.inputs.environment }}"
        elif [[ "${{ github.ref }}" == refs/tags/* ]]; then
          ENVIRONMENT="production"
        else
          ENVIRONMENT="staging"
        fi
        
        IMAGE_TAG="sha-$(echo ${{ github.sha }} | cut -c1-7)"
        
        echo "environment=$ENVIRONMENT" >> $GITHUB_OUTPUT
        echo "image-tag=$IMAGE_TAG" >> $GITHUB_OUTPUT
        echo "deploy-ready=true" >> $GITHUB_OUTPUT
        
        echo "Deploying to: $ENVIRONMENT"
        echo "Image tag: $IMAGE_TAG"

  pre-deployment-tests:
    name: Pre-deployment Tests
    runs-on: ubuntu-latest
    needs: [prepare]
    if: needs.prepare.outputs.deploy-ready == 'true'

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'npm'

    - name: Install dependencies
      run: npm ci

    - name: Run smoke tests
      run: |
        # Create smoke test script
        cat > smoke-test.js << 'EOF'
        const http = require('http');
        
        const TEST_URL = process.env.TEST_URL || 'http://localhost:3000';
        
        async function runSmokeTests() {
          console.log('Running smoke tests against:', TEST_URL);
          
          const tests = [
            { path: '/api/v1/health/live', expected: 200 },
            { path: '/api/v1/health/ready', expected: 200 },
            { path: '/metrics', expected: 200 },
          ];
          
          for (const test of tests) {
            try {
              const response = await fetch(`${TEST_URL}${test.path}`);
              if (response.status === test.expected) {
                console.log(`âœ… ${test.path} - ${response.status}`);
              } else {
                console.log(`âŒ ${test.path} - Expected ${test.expected}, got ${response.status}`);
                process.exit(1);
              }
            } catch (error) {
              console.log(`âŒ ${test.path} - Error: ${error.message}`);
              process.exit(1);
            }
          }
          
          console.log('All smoke tests passed!');
        }
        
        runSmokeTests();
        EOF
        
        echo "Smoke tests prepared for post-deployment validation"

    - name: Upload smoke test script
      uses: actions/upload-artifact@v3
      with:
        name: smoke-test-script
        path: smoke-test.js

  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: [prepare, pre-deployment-tests]
    if: needs.prepare.outputs.environment == 'staging' || (needs.prepare.outputs.environment == 'production' && github.ref != 'refs/heads/main')
    environment:
      name: staging
      url: https://staging-api.yourdomain.com

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: 'latest'

    - name: Configure Kubernetes context
      run: |
        # Configure kubectl to connect to staging cluster
        echo "${{ secrets.STAGING_KUBECONFIG }}" | base64 -d > $HOME/.kubeconfig
        export KUBECONFIG=$HOME/.kubeconfig
        kubectl config current-context

    - name: Deploy to staging
      run: |
        export KUBECONFIG=$HOME/.kubeconfig
        
        # Update image tag in deployment
        sed -i "s|gnaf-address-service:latest|${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.prepare.outputs.image-tag }}|g" k8s/gnaf-app.yaml
        
        # Apply configurations
        kubectl apply -f k8s/namespace.yaml
        kubectl apply -f k8s/configmap.yaml
        kubectl apply -f k8s/secrets.yaml
        kubectl apply -f k8s/postgres.yaml
        kubectl apply -f k8s/redis.yaml
        kubectl apply -f k8s/gnaf-app.yaml
        
        # Wait for rollout
        kubectl rollout status deployment/gnaf-app-deployment -n gnaf-system --timeout=600s

    - name: Run staging smoke tests
      run: |
        # Download smoke test script
        export KUBECONFIG=$HOME/.kubeconfig
        
        # Port forward to staging service
        kubectl port-forward -n gnaf-system svc/gnaf-app-service 8080:80 &
        PF_PID=$!
        sleep 10
        
        # Run smoke tests
        node smoke-test.js
        
        # Cleanup
        kill $PF_PID || true
      env:
        TEST_URL: http://localhost:8080

  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: [prepare, pre-deployment-tests, deploy-staging]
    if: needs.prepare.outputs.environment == 'production' && (success() || github.event.inputs.force_deploy == 'true')
    environment:
      name: production
      url: https://api.yourdomain.com

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: 'latest'

    - name: Configure Kubernetes context
      run: |
        # Configure kubectl to connect to production cluster
        echo "${{ secrets.PRODUCTION_KUBECONFIG }}" | base64 -d > $HOME/.kubeconfig
        export KUBECONFIG=$HOME/.kubeconfig
        kubectl config current-context

    - name: Pre-deployment backup
      run: |
        export KUBECONFIG=$HOME/.kubeconfig
        
        echo "Creating pre-deployment backup..."
        
        # Backup database
        kubectl exec -n gnaf-system deployment/postgres-deployment -- pg_dump -U gnaf_user gnaf_db > backup-$(date +%Y%m%d-%H%M%S).sql
        
        # Store current deployment state
        kubectl get deployment gnaf-app-deployment -n gnaf-system -o yaml > deployment-backup.yaml

    - name: Deploy to production with blue-green strategy
      run: |
        export KUBECONFIG=$HOME/.kubeconfig
        
        # Update image tag
        sed -i "s|gnaf-address-service:latest|${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.prepare.outputs.image-tag }}|g" k8s/gnaf-app.yaml
        
        echo "Starting blue-green deployment..."
        
        # Apply new configuration
        kubectl apply -f k8s/configmap.yaml
        kubectl apply -f k8s/gnaf-app.yaml
        
        # Wait for new pods to be ready
        kubectl rollout status deployment/gnaf-app-deployment -n gnaf-system --timeout=600s
        
        # Verify deployment
        kubectl get pods -n gnaf-system -l app=gnaf-address-service

    - name: Run production smoke tests
      run: |
        export KUBECONFIG=$HOME/.kubeconfig
        
        # Port forward to production service
        kubectl port-forward -n gnaf-system svc/gnaf-app-service 8080:80 &
        PF_PID=$!
        sleep 10
        
        # Run comprehensive smoke tests
        node smoke-test.js
        
        # Additional production-specific tests
        echo "Running production-specific validation..."
        
        # Test performance under load
        curl -f http://localhost:8080/api/v1/health/live
        curl -f http://localhost:8080/api/v1/health/ready
        curl -f http://localhost:8080/metrics
        
        # Cleanup
        kill $PF_PID || true
      env:
        TEST_URL: http://localhost:8080

    - name: Upload deployment artifacts
      uses: actions/upload-artifact@v3
      if: always()
      with:
        name: production-deployment-artifacts
        path: |
          backup-*.sql
          deployment-backup.yaml

  post-deployment:
    name: Post-deployment Tasks
    runs-on: ubuntu-latest
    needs: [prepare, deploy-staging, deploy-production]
    if: always() && (needs.deploy-staging.result == 'success' || needs.deploy-production.result == 'success')

    steps:
    - name: Update deployment status
      run: |
        ENVIRONMENT="${{ needs.prepare.outputs.environment }}"
        IMAGE_TAG="${{ needs.prepare.outputs.image-tag }}"
        
        echo "Deployment completed successfully!"
        echo "Environment: $ENVIRONMENT"
        echo "Image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:$IMAGE_TAG"
        
        # Update deployment tracking
        echo "$(date): Deployed $IMAGE_TAG to $ENVIRONMENT" >> deployment-history.txt

    - name: Run post-deployment monitoring check
      run: |
        echo "Setting up post-deployment monitoring..."
        
        # Wait for metrics to populate
        sleep 60
        
        echo "Monitoring setup complete. Check Grafana dashboards for deployment metrics."

    - name: Notify stakeholders
      if: needs.deploy-production.result == 'success'
      run: |
        echo "ðŸš€ Production deployment successful!"
        echo "Version: ${{ needs.prepare.outputs.image-tag }}"
        echo "Time: $(date)"
        echo "Deployed by: ${{ github.actor }}"
        
        # Add webhook notification here for Slack, Teams, etc.
        # curl -X POST -H 'Content-type: application/json' \
        #   --data '{"text":"ðŸš€ G-NAF Service deployed to production successfully!"}' \
        #   ${{ secrets.SLACK_WEBHOOK_URL }}

  rollback:
    name: Rollback on Failure
    runs-on: ubuntu-latest
    needs: [prepare, deploy-staging, deploy-production]
    if: failure() && (needs.deploy-staging.result == 'failure' || needs.deploy-production.result == 'failure')

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: 'latest'

    - name: Rollback deployment
      run: |
        ENVIRONMENT="${{ needs.prepare.outputs.environment }}"
        
        if [ "$ENVIRONMENT" = "production" ]; then
          echo "${{ secrets.PRODUCTION_KUBECONFIG }}" | base64 -d > $HOME/.kubeconfig
        else
          echo "${{ secrets.STAGING_KUBECONFIG }}" | base64 -d > $HOME/.kubeconfig
        fi
        
        export KUBECONFIG=$HOME/.kubeconfig
        
        echo "Rolling back deployment in $ENVIRONMENT..."
        kubectl rollout undo deployment/gnaf-app-deployment -n gnaf-system
        kubectl rollout status deployment/gnaf-app-deployment -n gnaf-system --timeout=300s
        
        echo "Rollback completed"

    - name: Notify rollback
      run: |
        echo "ðŸ”„ Deployment rolled back due to failures"
        echo "Environment: ${{ needs.prepare.outputs.environment }}"
        echo "Time: $(date)"